<!DOCTYPE html>
<html class="html" lang="en-US">
 <head>

  <script type="text/javascript">
   if(typeof Muse == "undefined") window.Muse = {}; window.Muse.assets = {"required":["jquery-1.8.3.min.js", "museutils.js", "jquery.watch.js", "jquery.musemenu.js", "memoization.css"], "outOfDate":[]};
</script>
  
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8"/>
  <meta name="generator" content="2015.0.2.310"/>
  <link rel="shortcut icon" href="../images/favicon.ico?4041064623"/>
  <title>Memoization</title>
  <meta name="viewport" content="width=600"/>
  <link rel="canonical" href="http://tobin.yehle.io/memoization.html"/>
  <!-- CSS -->
  <link rel="stylesheet" type="text/css" href="../css/site_global.css?445134775"/>
  <link rel="stylesheet" type="text/css" href="css/master_main.css?314445842"/>
  <link rel="stylesheet" type="text/css" href="css/master_page.css?4073057265"/>
  <link rel="stylesheet" type="text/css" href="css/memoization.css?64688224" id="pagesheet"/>
  <!-- Other scripts -->
  <script type="text/javascript">
   document.documentElement.className += ' js';
var __adobewebfontsappname__ = "muse";
</script>
  <!-- JS includes -->
  <!--[if lt IE 9]>
  <script src="../scripts/html5shiv.js?4241844378" type="text/javascript"></script>
  <![endif]-->
  <script type="text/javascript">
   document.write('\x3Cscript src="' + (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//webfonts.creativecloud.com/open-sans-condensed:n7:default.js" type="text/javascript">\x3C/script>');
</script>
  <script type="text/javascript">
   document.write('\x3Cscript src="' + (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//use.typekit.net/ik/hmGqRS8vlH9RXinDmGNfaJiYQJG_kjQinaV1uXu9EiGfe7bgfFcft6IPH2waw2wUwR8L5AmyFesKwAwkjQ9owR8KF2Zy5QMDFRJtZRqDFe9U5AJ-Yaszjc80O188-eU8Oc8zOfG0ieNK-At0pAmGde90-AvKIYFziW4RZPuDZW4TZKu3ScvK2aFziW4RZPuRdhs8OWgkdkGHfJKkMsMMeMb6MKGHfH0JMsMgeMS6MKGHfHPbMsMgeM96MqGIQWmDZZMgr7_bn69.js" type="text/javascript">\x3C/script>');
</script>
  <!-- Other scripts -->
  <script type="text/javascript">
   try {Typekit.load();} catch(e) {}
</script>
   </head>
 <body>

  <div class="rounded-corners clearfix" id="page"><!-- column -->
   <div class="position_content" id="page_position_content">
    <div class="clearfix colelem" id="pu1183"><!-- group -->
     <div class="browser_width grpelem" id="u1183-bw">
      <div class="clearfix" id="u1183"><!-- group -->
       <div class="Headline-Style clearfix grpelem" id="u1215-4"><!-- content -->
        <h1>{</h1>
       </div>
       <div class="Headline-Style clearfix grpelem" id="u1214-4"><!-- content -->
        <h1>Tobin Yehle</h1>
       </div>
       <div class="Headline-Style clearfix grpelem" id="u1216-4"><!-- content -->
        <h1>}</h1>
       </div>
      </div>
     </div>
     <div class="browser_width grpelem" id="menuu1185-bw">
      <nav class="MenuBar clearfix" id="menuu1185"><!-- horizontal box -->
       <div class="MenuItemContainer clearfix grpelem" id="u1186"><!-- vertical box -->
        <a class="nonblock nontext MenuItem MenuItemWithSubMenu clearfix colelem" id="u1187" href="index.html"><!-- horizontal box --><div class="MenuItemLabel NoWrap clearfix grpelem" id="u1188-4"><!-- content --><p>About</p></div></a>
       </div>
       <div class="MenuItemContainer clearfix grpelem" id="u1207"><!-- vertical box -->
        <a class="nonblock nontext MenuItem MenuItemWithSubMenu clearfix colelem" id="u1208" href="research.html"><!-- horizontal box --><div class="MenuItemLabel NoWrap clearfix grpelem" id="u1210-4"><!-- content --><p>Research</p></div></a>
       </div>
       <div class="MenuItemContainer clearfix grpelem" id="u1200"><!-- vertical box -->
        <a class="nonblock nontext MenuItem MenuItemWithSubMenu clearfix colelem" id="u1203" href="projects.html"><!-- horizontal box --><div class="MenuItemLabel NoWrap clearfix grpelem" id="u1206-4"><!-- content --><p>Projects</p></div></a>
       </div>
       <div class="MenuItemContainer clearfix grpelem" id="u1193"><!-- vertical box -->
        <a class="nonblock nontext MenuItem MenuItemWithSubMenu clearfix colelem" id="u1194" href="snippets.html"><!-- horizontal box --><div class="MenuItemLabel NoWrap clearfix grpelem" id="u1196-4"><!-- content --><p>Snippets</p></div></a>
       </div>
      </nav>
     </div>
    </div>
    <div class="Headline-Style clearfix colelem" id="u1249-4"><!-- content -->
     <h1>TAIL CALL OPTIMIZED MEMOIZATION IN SCALA</h1>
    </div>
    <div class="clearfix colelem" id="pu1287-4"><!-- group -->
     <div class="clearfix grpelem" id="u1287-4"><!-- content -->
      <p class="Code-Style" id="u1287-2">//</p>
     </div>
     <div class="grpelem" id="u1288"><!-- simple frame --></div>
     <div class="grpelem" id="u1289"><!-- simple frame --></div>
    </div>
    <div class="Paragraph clearfix colelem" id="u1250-4"><!-- content -->
     <p>Memoization is a technique where one saves the result of a function so if the function is ever called again with the same inputs it does not have to compute the result a second time. The example I will use here is the Fibonacci sequence. The obvious recursive implementation given below has comically terrible performance.</p>
    </div>
    <div class="clearfix colelem" id="u1256-16"><!-- content -->
     <p class="Code-Style">def fib(n: Int):Long = {</p>
     <p class="Code-Style">&nbsp; case _ if n &lt; 0 =&gt;</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp; throw new Exception(&quot;negative input&quot;)</p>
     <p class="Code-Style">&nbsp; case 0 =&gt; 1</p>
     <p class="Code-Style">&nbsp; case 1 =&gt; 1</p>
     <p class="Code-Style">&nbsp; case _ =&gt; fib(n-1) + fib(n-2)</p>
     <p class="Code-Style">}</p>
    </div>
    <div class="Paragraph clearfix colelem" id="u1251-15"><!-- content -->
     <p>I like this definition. I think it is easier to understand than an optimized version with loops and lists. Unfortunately this definition is unusably slow. Computing the value of the 10th Fibonacci number using this implementation requires 177 calls to <span class="code-inline">fib</span>! Many of these calls are calling <span class="code-inline">fib</span> with the same arguments. <span class="code-inline">fib(1)</span> was called 55 times.</p>
     <p>&nbsp;</p>
     <p>Bummer, but memoization can save it! Since <span class="code-inline">fib</span> is a pure function, calls with the same arguments will always return the same value, so there is no need to compute the result again. The implementation below uses a map to store the results of previous computations.</p>
    </div>
    <div class="clearfix colelem" id="u1257-35"><!-- content -->
     <p class="Code-Style">val cache = mutable.Map.empty[Int, Long]</p>
     <p class="Code-Style">&nbsp;</p>
     <p class="Code-Style">def memoizedFib(n: Int): Long = {</p>
     <p class="Code-Style">&nbsp; cache.get(n) match {</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp; case Some(answer) =&gt; answer</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp; case None =&gt;</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val answer = n match {</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case _ if n &lt; 0 =&gt;</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new Exception(&quot;negative input&quot;)</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0 =&gt; 1</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1 =&gt; 1</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case _ =&gt; memoizedFib(n-1) + memoizedFib(n-2)</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cache.update(n, answer)</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer</p>
     <p class="Code-Style">&nbsp; }</p>
     <p class="Code-Style">}</p>
    </div>
    <div class="Paragraph clearfix colelem" id="u1252-4"><!-- content -->
     <p>This version has the desired linear performance, requiring only 11 calls to fib to compute the value of the 10th number in the sequence. Great, but that code is ugly and no fun to write.</p>
    </div>
    <div class="clearfix colelem" id="pu1259"><!-- group -->
     <div class="grpelem" id="u1259"><!-- simple frame --></div>
     <div class="clearfix grpelem" id="u1258-4"><!-- content -->
      <p class="Code-Style" id="u1258-2">//</p>
     </div>
     <div class="grpelem" id="u1260"><!-- simple frame --></div>
    </div>
    <div class="clearfix colelem" id="u1253-32"><!-- content -->
     <h2 class="Subhead-Style" id="u1253-2">Generalizing to any Function</h2>
     <p class="Paragraph">What I want is a small change I can make to the original function to get the power of memoization. The first step is to make a more general <span class="code-inline">memoize</span> function.</p>
     <p class="Paragraph">&nbsp;</p>
     <p class="Paragraph">Due to limitations in scala generics the functions I will be able to memoize will all have the type signature <span class="code-inline">I=&gt;O</span>, that is they accept only one input of type <span class="code-inline">I</span> and produce an output of type <span class="code-inline">O</span>.</p>
     <p class="Paragraph">&nbsp;</p>
     <p class="Paragraph">At this point I must asked myself: what is memoization really? Well there is one function that may be able to give the answer very quickly, but not always. I will call this function <span class="code-inline">check</span> and its type is <span class="code-inline">I=&gt;Option[O]</span>. After I compute a result the hard way I should save it away so <span class="code-inline">check</span> can return it in the future. I will call this saving function <span class="code-inline">update </span>and its type is <span class="code-inline">(I,O)=&gt;Unit</span>. Using this framework I implemented a generic <span class="code-inline">memoize</span> function.</p>
    </div>
    <div class="clearfix colelem" id="u1255-24"><!-- content -->
     <p class="Code-Style">def memoize[I, O](fn: I =&gt; O,</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; check: I =&gt; Option[O],</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; update: (I, O) =&gt; Unit): I =&gt; O = {</p>
     <p class="Code-Style">&nbsp; (input: I) =&gt; check(input) match {</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp; case Some(answer) =&gt; answer</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp; case None =&gt;</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val answer = fn(input)</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; update(input, answer)</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; answer</p>
     <p class="Code-Style">&nbsp; }</p>
     <p class="Code-Style">}</p>
    </div>
    <div class="Paragraph clearfix colelem" id="u1254-8"><!-- content -->
     <p>Cool! I also implemented a <span class="code-inline">memoizeMap</span> function that memoizes some function, <span class="code-inline">I=&gt;O</span>, using a map for convenience.</p>
    </div>
    <div class="clearfix colelem" id="u1261-10"><!-- content -->
     <p class="Code-Style">def memoizeMap[I, O](fn: I =&gt; O): I =&gt; O = {</p>
     <p class="Code-Style">&nbsp; val cache = mutable.Map.empty[I, O]</p>
     <p class="Code-Style">&nbsp; memoize(fn, cache.get, cache.update)</p>
     <p class="Code-Style">}</p>
    </div>
    <div class="Paragraph clearfix colelem" id="u1262-4"><!-- content -->
     <p>Now I can finally get the syntax I want. Unfortunately `def` is somewhat special in scala, so the best syntax I could wrangle is the following.</p>
    </div>
    <div class="clearfix colelem" id="u1263-16"><!-- content -->
     <p class="Code-Style">lazy val fib: Int =&gt; Long = memoizeMap {</p>
     <p class="Code-Style">&nbsp; case n if n &lt; 0 =&gt;</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp; throw new Exception(&quot;negative input&quot;)</p>
     <p class="Code-Style">&nbsp; case 0 =&gt; 1</p>
     <p class="Code-Style">&nbsp; case 1 =&gt; 1</p>
     <p class="Code-Style">&nbsp; case n =&gt; fib(n-1) + fib(n-2)</p>
     <p class="Code-Style">}</p>
    </div>
    <div class="Paragraph clearfix colelem" id="u1264-10"><!-- content -->
     <p>The <span class="code-inline">lazy</span> keyword is the only way I could figure out to get <span class="code-inline">letrec</span> behavior without using <span class="code-inline">def</span>.</p>
    </div>
    <div class="clearfix colelem" id="pu1267"><!-- group -->
     <div class="grpelem" id="u1267"><!-- simple frame --></div>
     <div class="clearfix grpelem" id="u1266-4"><!-- content -->
      <p class="Code-Style" id="u1266-2">//</p>
     </div>
     <div class="grpelem" id="u1268"><!-- simple frame --></div>
    </div>
    <div class="clearfix colelem" id="u1265-18"><!-- content -->
     <h2 class="Subhead-Style" id="u1265-2">Tail Recursion</h2>
     <p class="Paragraph">What if I want to compute the 100 000th Fibonacci number though? Things get a little more tricky. The syntax I ended up with is not very readable, so iteration is probably a more useful (and faster) solution for most functions. There are many functions that are not easily represented as iteration for which this is useful.</p>
     <p class="Paragraph">&nbsp;</p>
     <p class="Paragraph">First of all: what is tail recursion? A tail recursive function only has calls to itself in tail position. In a language like Java with an explicit return keyword this means the only recursive calls are of the form <span class="code-inline">return myself(args);</span>. More generally, the result of the recursive function is equal to the recursive call, or some atomic value.</p>
     <p class="Paragraph">&nbsp;</p>
     <p class="Paragraph">The Fibonacci function branches into two subcalls, <span class="code-inline">fib(n-1)</span> and <span class="code-inline">fib(n-2)</span>, at ever step which introduces its own set of problems. For starters&nbsp; I implemented factorial.</p>
    </div>
    <div class="clearfix colelem" id="u1269-14"><!-- content -->
     <p class="Code-Style">lazy val fact: Int =&gt; BigInt = memoizeMap {</p>
     <p class="Code-Style">&nbsp; case n if n &lt; 0 =&gt;</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp; throw new Exception(&quot;negative input&quot;)</p>
     <p class="Code-Style">&nbsp; case 0 =&gt; 1</p>
     <p class="Code-Style">&nbsp; case n =&gt; n * fact(n - 1)</p>
     <p class="Code-Style">}</p>
    </div>
    <div class="Paragraph clearfix colelem" id="u1270-8"><!-- content -->
     <p>This implementation is not tail recursive. Notice the value of a call to <span class="code-inline">fact</span> is <span class="code-inline">n * fact(...)</span>. The traditional way to make this function tail recursive is include an accumulator as an argument to the function. Unfortunately this will make the memoization useless because every intermediate value is unique to the original call.</p>
    </div>
    <div class="clearfix colelem" id="pu1272"><!-- group -->
     <div class="grpelem" id="u1272"><!-- simple frame --></div>
     <div class="clearfix grpelem" id="u1271-4"><!-- content -->
      <p class="Code-Style" id="u1271-2">//</p>
     </div>
     <div class="grpelem" id="u1273"><!-- simple frame --></div>
    </div>
    <div class="clearfix colelem" id="u1274-8"><!-- content -->
     <h2 class="Subhead-Style" id="u1274-2">Continuation Passing Style</h2>
     <p class="Paragraph">I will leave a full explanation of continuation passing style to others. In this specific case the continuation acts as a return for the recursive function. The recursive function must, at some point, call the continuation it is passed with the result it is to return. Note the type of the continuation here is <span class="code-inline">O=&gt;O</span>. The following is the same factorial function rewritten in continuation passing style. This change lets me write all recursive calls in tail position.</p>
    </div>
    <div class="clearfix colelem" id="u1275-20"><!-- content -->
     <p class="Code-Style">def cpsFact(input: Int, kont: BigInt=&gt;BigInt): BigInt = {</p>
     <p class="Code-Style">&nbsp; input match {</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp; case n if n &lt; 0 =&gt;</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new Exception(&quot;negative input&quot;)</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp; case 0 =&gt; kont(1)</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp; case n =&gt; cpsFact(n-1,</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (result: BigInt) =&gt; kont(n * result))</p>
     <p class="Code-Style">&nbsp; }</p>
     <p class="Code-Style">}</p>
    </div>
    <div class="Paragraph clearfix colelem" id="u1276-4"><!-- content -->
     <p>I wrote a new memoizing function that accepts CPS functions. Unlike the first one this memoizer is properly tail recursive. The update step is moved into the continuation of the recursive call, ensuring the stack from of the lambda can be torn down.</p>
    </div>
    <div class="clearfix colelem" id="u1277-28"><!-- content -->
     <p class="Code-Style">def memoizeRec[I, O](fn: (I, O=&gt;O) =&gt; O,</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; check: I =&gt; Option[O],</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; update: (I, O) =&gt; Unit):</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (I, O=&gt;O) =&gt; O = {</p>
     <p class="Code-Style">&nbsp; (input: I, kont: O=&gt;O) =&gt; check(input) match {</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp; case Some(answer) =&gt; kont(answer)</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp; case None =&gt; fn(input,</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (result: O) =&gt; {</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; update(input, result)</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kont(result)</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; })</p>
     <p class="Code-Style">&nbsp; }</p>
     <p class="Code-Style">}</p>
    </div>
    <div class="Paragraph clearfix colelem" id="u1278-6"><!-- content -->
     <p>Unfortunately the scala compiler will not tail call optimize lazy vals, so I needed a different solution. The scala standard library had all I needed to fix the problem tucked away in <span class="code-inline">scala.util.control.TailCalls</span>. The implementation containing the tail call optimization is given below.</p>
    </div>
    <div class="clearfix colelem" id="u1279-60"><!-- content -->
     <p class="Code-Style">def memoizeRec[I, O](fn: (I, O=&gt;TailRec[O]) =&gt; TailRec[O],</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; check: I =&gt; Option[O],</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; update: (I, O) =&gt; Unit):</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (I, O=&gt;TailRec[O]) =&gt; TailRec[O] = {</p>
     <p class="Code-Style">&nbsp; (input: I, kont: O=&gt;TailRec[O]) =&gt; check(input) match {</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp; case Some(answer) =&gt; tailcall(kont(answer))</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp; case None =&gt;</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tailcall(fn(input, (result: O) =&gt; {</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; update(input, result)</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tailcall(kont(result))</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }))</p>
     <p class="Code-Style">&nbsp; }</p>
     <p class="Code-Style">}</p>
     <p class="Code-Style">&nbsp;</p>
     <p class="Code-Style">def memoizeRecMap[I, O](fn: (I, O=&gt;TailRec[O]) =&gt; TailRec[O]): (I, O=&gt;TailRec[O]) =&gt; TailRec[O] = {</p>
     <p class="Code-Style">&nbsp; val cache = mutable.Map.empty[I, O]</p>
     <p class="Code-Style">&nbsp; memoizeRec(fn, cache.get, cache.update)</p>
     <p class="Code-Style">}</p>
     <p class="Code-Style">&nbsp;</p>
     <p class="Code-Style">lazy val cpsFactTail: (Int, BigInt=&gt;TailRec[BigInt]) =&gt;</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TailRec[BigInt] = memoizeRecMap {</p>
     <p class="Code-Style">&nbsp; (input, kont) =&gt; input match {</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp; case n if n &lt; 0 =&gt;</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new Exception(&quot;negative input&quot;)</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp; case 0 =&gt; tailcall(kont(1))</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp; case n =&gt;</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tailcall(cpsFactTail(n-1,</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (result: BigInt) =&gt; tailcall(kont(n * result))))</p>
     <p class="Code-Style">&nbsp; }</p>
     <p class="Code-Style">}</p>
    </div>
    <div class="Paragraph clearfix colelem" id="u1280-4"><!-- content -->
     <p>I said earlier that the Fibonacci sequence was harder to express using only tail calls. You are only allowed to make a single recursive call, so the continuation must contain the other recursive call. Remember continuations must also only contain tail calls, so the continuation passed to the recursive call will be a tail recursive call with a final continuation calling the outer continuation with the final result of this function call. Not very intuitive, I know.</p>
    </div>
    <div class="clearfix colelem" id="u1281-26"><!-- content -->
     <p class="Code-Style">lazy val cpsFibTail: (Int, BigInt=&gt;TailRec[BigInt]) =&gt;</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TailRec[BigInt] = memoizeRecMap {</p>
     <p class="Code-Style">&nbsp; (input, kont) =&gt; input match {</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp; case n if n &lt; 0 =&gt;</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new Exception(&quot;negative input&quot;)</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp; case 0 =&gt; tailcall(kont(1))</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp; case 1 =&gt; tailcall(kont(1))</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp; case n =&gt; tailcall(cpsFibTail(n-1, (res1: BigInt) =&gt;</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tailcall(cpsFibTail(n-2, (res2: BigInt) =&gt;</p>
     <p class="Code-Style">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tailcall(kont(res1 + res2))))))</p>
     <p class="Code-Style">&nbsp; }</p>
     <p class="Code-Style">}</p>
    </div>
    <div class="Paragraph clearfix colelem" id="u1282-4"><!-- content -->
     <p>With this implementation I was able to compute the 100 000th Fibonacci number in just 2.2 seconds.</p>
    </div>
    <div class="clearfix colelem" id="pu1284"><!-- group -->
     <div class="grpelem" id="u1284"><!-- simple frame --></div>
     <div class="clearfix grpelem" id="u1283-4"><!-- content -->
      <p class="Code-Style" id="u1283-2">//</p>
     </div>
     <div class="grpelem" id="u1285"><!-- simple frame --></div>
    </div>
    <div class="clearfix colelem" id="u1286-16"><!-- content -->
     <h2 class="Subhead-Style" id="u1286-2">Limitations</h2>
     <p class="Paragraph">Functions must be pure. Memoizing <span class="code-inline">Random.nextInt</span> is not very useful.</p>
     <p class="Paragraph">&nbsp;</p>
     <p class="Paragraph">Continuations are not easy to read. All of the simplicity of the initial Fibonacci function has been lost. In most cases arbitrary depth recursion is not a requirement, so the more elegant <span class="code-inline">memoizeMap</span> version could be used instead.</p>
     <p class="Paragraph">&nbsp;</p>
     <p class="Paragraph">Input must be a single type. Without macros or dependent types accepting an arbitrary number inputs in a typesafe manner is simply not possible. Yes you could write a different version that accepts two input functions. In my mind this is not an acceptable solution.</p>
    </div>
    <div class="verticalspacer"></div>
    <div class="browser_width colelem" id="u1170-bw">
     <div class="clearfix" id="u1170"><!-- group -->
      <a class="nonblock nontext clip_frame grpelem" id="u1176" href="https://bitbucket.org/tobinyehle/"><!-- image --><img class="block" id="u1176_img" src="../images/bitbucket_white.png" alt="" width="32" height="32"/></a>
      <a class="nonblock nontext clearfix grpelem" id="u1175-4" href="https://bitbucket.org/tobinyehle/"><!-- content --><p class="Paragraph" id="u1175-2">tobinyehle</p></a>
      <div class="clearfix grpelem" id="ppu1173-4"><!-- column -->
       <div class="clearfix colelem" id="pu1173-4"><!-- group -->
        <div class="Headline-Style clearfix grpelem" id="u1173-4"><!-- content -->
         <h1>{</h1>
        </div>
        <div class="Headline-Style clearfix grpelem" id="u1172-4"><!-- content -->
         <h1>Tobin Yehle</h1>
        </div>
        <div class="Headline-Style clearfix grpelem" id="u1174-4"><!-- content -->
         <h1>}</h1>
        </div>
       </div>
       <div class="Paragraph clearfix colelem" id="u1171-4"><!-- content -->
        <p>tobin {dot} yehle {at} gmail {dot} com</p>
       </div>
      </div>
      <a class="nonblock nontext clip_frame grpelem" id="u1178" href="https://github.com/tyehle"><!-- image --><img class="block" id="u1178_img" src="../images/github_white-01.png" alt="" width="32" height="32"/></a>
      <a class="nonblock nontext clearfix grpelem" id="u1180-4" href="https://github.com/tyehle"><!-- content --><p class="Paragraph" id="u1180-2">tyehle</p></a>
     </div>
    </div>
   </div>
  </div>
  <!-- JS includes -->
  <script type="text/javascript">
   if (document.location.protocol != 'https:') document.write('\x3Cscript src="http://musecdn2.businesscatalyst.com/scripts/4.0/jquery-1.8.3.min.js" type="text/javascript">\x3C/script>');
</script>
  <script type="text/javascript">
   window.jQuery || document.write('\x3Cscript src="../scripts/jquery-1.8.3.min.js" type="text/javascript">\x3C/script>');
</script>
  <script src="../scripts/museutils.js?275725342" type="text/javascript"></script>
  <script src="../scripts/jquery.watch.js?3999102769" type="text/javascript"></script>
  <script src="../scripts/jquery.musemenu.js?4042164668" type="text/javascript"></script>
  <!-- Other scripts -->
  <script type="text/javascript">
   $(document).ready(function() { try {
(function(){var a={},b=function(a){if(a.match(/^rgb/))return a=a.replace(/\s+/g,"").match(/([\d\,]+)/gi)[0].split(","),(parseInt(a[0])<<16)+(parseInt(a[1])<<8)+parseInt(a[2]);if(a.match(/^\#/))return parseInt(a.substr(1),16);return 0};(function(){$('link[type="text/css"]').each(function(){var b=($(this).attr("href")||"").match(/\/?css\/([\w\-]+\.css)\?(\d+)/);b&&b[1]&&b[2]&&(a[b[1]]=b[2])})})();(function(){$("body").append('<div class="version" style="display:none; width:1px; height:1px;"></div>');
for(var c=$(".version"),d=0;d<Muse.assets.required.length;){var f=Muse.assets.required[d],g=f.match(/([\w\-\.]+)\.(\w+)$/),k=g&&g[1]?g[1]:null,g=g&&g[2]?g[2]:null;switch(g.toLowerCase()){case "css":k=k.replace(/\W/gi,"_").replace(/^([^a-z])/gi,"_$1");c.addClass(k);var g=b(c.css("color")),h=b(c.css("background-color"));g!=0||h!=0?(Muse.assets.required.splice(d,1),"undefined"!=typeof a[f]&&(g!=a[f]>>>24||h!=(a[f]&16777215))&&Muse.assets.outOfDate.push(f)):d++;c.removeClass(k);break;case "js":k.match(/^jquery-[\d\.]+/gi)&&
typeof $!="undefined"?Muse.assets.required.splice(d,1):d++;break;default:throw Error("Unsupported file type: "+g);}}c.remove();if(Muse.assets.outOfDate.length||Muse.assets.required.length)c="Some files on the server may be missing or incorrect. Clear browser cache and try again. If the problem persists please contact website author.",(d=location&&location.search&&location.search.match&&location.search.match(/muse_debug/gi))&&Muse.assets.outOfDate.length&&(c+="\nOut of date: "+Muse.assets.outOfDate.join(",")),d&&Muse.assets.required.length&&(c+="\nMissing: "+Muse.assets.required.join(",")),alert(c)})()})();/* body */
Muse.Utils.transformMarkupToFixBrowserProblemsPreInit();/* body */
Muse.Utils.prepHyperlinks(true);/* body */
Muse.Utils.resizeHeight()/* resize height */
Muse.Utils.initWidget('.MenuBar', function(elem) { return $(elem).museMenu(); });/* unifiedNavBar */
Muse.Utils.fullPage('#page');/* 100% height page */
Muse.Utils.showWidgetsWhenReady();/* body */
Muse.Utils.transformMarkupToFixBrowserProblems();/* body */
} catch(e) { if (e && 'function' == typeof e.notify) e.notify(); else Muse.Assert.fail('Error calling selector function:' + e); }});
</script>
   </body>
</html>
